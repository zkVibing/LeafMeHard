use dep::trie::blake2b::blake2b;

fn main(secret_input: [u8; 32], expected_hash: pub [u8; 32]) {
    // Compute Blake2b hash of the secret input
    let computed_hash = blake2b(secret_input);

    // Verify that the computed hash matches the expected hash
    assert(computed_hash == expected_hash);
}

#[test]
fn test_blake2b_preimage_knowledge() {
    // Test data: we know the preimage that produces a specific hash
    let secret_input = [
        0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
        0x61, 0x20, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74,
        0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
        0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x65, 0x73
    ]; // "this is a secret message for tes"

    let expected_hash = blake2b(secret_input);

    // This should pass - we know the preimage
    main(secret_input, expected_hash);
}

#[test]
fn test_blake2b_different_inputs() {
    let input1 = [
        0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f,
        0x72, 0x6c, 0x64, 0x21, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]; // "Hello World!" padded

    let input2 = [
        0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x4e, 0x6f,
        0x69, 0x72, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]; // "Hello Noir!" padded

    let hash1 = blake2b(input1);
    let hash2 = blake2b(input2);

    // Verify that different inputs produce different hashes
    let mut are_different = false;
    for i in 0..32 {
        if hash1[i] != hash2[i] {
            are_different = true;
        }
    }
    assert(are_different);
}
